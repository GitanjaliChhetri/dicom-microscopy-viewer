<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: decode.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: decode.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>// Allocate decoders
import imageType from 'image-type'
import dcmjs from 'dcmjs'
// import libjpegturbowasm from '@cornerstone/codec-libjpeg-turbo/dist/libjpegturbowasm.js'
// import OpenJPEGWASM from '@cornerstone/codec-openjpeg/dist/openjpegwasm.js'
// import CharLSWASM from '@cornerstone/codec-charls/dist/charlswasm.js'

let jpegDecoder
if (typeof libjpegturbowasm === 'function') {
  libjpegturbowasm().then(function (libjpegturbo) {// eslint-disable-line
    jpegDecoder = new libjpegturbo.JPEGDecoder()
    console.info('jpegDecoder initialized.')
  })
}

let jp2jpxDecoder
if (typeof OpenJPEGWASM === 'function') {
  OpenJPEGWASM().then(function (openjpegwasm) {// eslint-disable-line
    jp2jpxDecoder = new openjpegwasm.J2KDecoder()
    console.info('jp2jpxDecoder initialized.')
  })
}

let jlsDecoder
if (typeof CharLSWASM === 'function') {
  CharLSWASM().then(function (charlswasm) {// eslint-disable-line
    jlsDecoder = new charlswasm.JpegLSDecoder()
    console.info('jlsDecoder initialized.')
  })
}

function decodeFrame ({
  frame,
  bitsAllocated,
  pixelRepresentation,
  columns,
  rows,
  samplesPerPixel
}) {
  const { decodedFrame, metadata } = _checkImageTypeAndDecode({
    frame,
    bitsAllocated,
    pixelRepresentation,
    columns,
    rows,
    samplesPerPixel
  })

  if (metadata.bitsAllocated !== bitsAllocated) {
    throw new Error('Frame does not have expected Bits Allocated.')
  }
  if (metadata.rows !== rows) {
    throw new Error('Frame does not have expected Rows.')
  }
  if (metadata.columns !== columns) {
    throw new Error('Frame does not have expected Columns.')
  }
  if (metadata.samplesPerPixel !== samplesPerPixel) {
    throw new Error('Frame does not have expected Samples Per Pixel.')
  }
  if (metadata.pixelRepresentation !== pixelRepresentation) {
    throw new Error('Frame does not have expected Pixel Representation.')
  }

  const length = rows * columns * samplesPerPixel * (bitsAllocated / 8)
  if (length !== decodedFrame.length) {
    throw new Error('Frame value does not have expected length.')
  }

  const signed = pixelRepresentation === 1
  let pixelArray
  let bitsPerSample
  switch (bitsAllocated) {
    case 1:
      pixelArray = dcmjs.data.BitArray.unpack(decodedFrame) // Uint8Array
      bitsPerSample = 8 // unpacked to 8-bit
      break
    case 8:
      if (signed) {
        pixelArray = new Int8Array(decodedFrame)
      } else {
        pixelArray = new Uint8Array(decodedFrame)
      }
      bitsPerSample = 8
      break
    case 16:
      if (pixelRepresentation === 1) {
        pixelArray = new Int16Array(
          decodedFrame.buffer,
          decodedFrame.byteOffset,
          decodedFrame.byteLength / 2
        )
      } else {
        pixelArray = new Uint16Array(
          decodedFrame.buffer,
          decodedFrame.byteOffset,
          decodedFrame.byteLength / 2
        )
      }
      bitsPerSample = 16
      break
    case 32:
      pixelArray = new Float32Array(
        decodedFrame.buffer,
        decodedFrame.byteOffset,
        decodedFrame.byteLength / 4
      )
      bitsPerSample = 32
      break
    case 64:
      pixelArray = new Float64Array(
        decodedFrame.buffer,
        decodedFrame.byteOffset,
        decodedFrame.byteLength / 8
      )
      bitsPerSample = 64
      break
    default:
      throw new Error(
        'The pixel bit depth ' + bitsAllocated +
        ' is not supported by the offscreen rendering.'
      )
  }

  return {
    pixelArray,
    bitsPerSample
  }
}

/** Check image type of a compressed array and returns a decoded image
 * NOTE: for png at the moment we don't have a library for decoding,
 *       undefined is returned.
 * @param {number[]} frames - buffer of the image array
 * @returns {obejct} image array, frameInfo and mediaType.
 * @private
 */
function _checkImageTypeAndDecode ({
  frame,
  bitsAllocated,
  pixelRepresentation,
  columns,
  rows,
  samplesPerPixel
}) {
  const byteArray = new Uint8Array(frame)
  const imageTypeObject = imageType(byteArray)

  if (imageTypeObject === null) {
    return {
      decodedFrame: byteArray,
      metadata: {
        bitsAllocated: bitsAllocated,
        rows: rows,
        columns: columns,
        samplesPerPixel: samplesPerPixel,
        pixelRepresentation: pixelRepresentation
      }
    }
  }

  function toHex (value) {
    return value.toString(16).padStart(2, '0').toUpperCase()
  }

  /**
   * This hack is required to distinguish JPEG-LS from baseline JPEG, which
   * both contain the JPEG Start of Image (SOI) marker and share the first
   * three bytes.
   */
  let mediaType = imageTypeObject.mime
  if ((toHex(byteArray[3]) === 'F7') || (toHex(byteArray[3]) === 'E8')) {
    mediaType = 'image/jls'
  }

  let decoder
  if (mediaType === 'image/jpeg') {
    if (!jpegDecoder) {
      throw new Error('JPEG decoder was not initialized.')
    }
    decoder = jpegDecoder
  } else if (mediaType === 'image/jp2' || mediaType === 'image/jpx') {
    if (!jp2jpxDecoder) {
      throw new Error('JPEG 2000 Decoder was not initialized.')
    }
    decoder = jp2jpxDecoder
  } else if (mediaType === 'image/jls') {
    if (!jlsDecoder) {
      throw new Error('JPEG-LS decoder was not initialized.')
    }
    decoder = jlsDecoder
  } else {
    throw new Error(
      'The media type ' + mediaType +
      ' is not supported by the offscreen rendering engine.'
    )
  }

  const { frameBuffer, frameInfo } = _decodeImage(decoder, byteArray)

  return {
    decodedFrame: frameBuffer,
    metadata: {
      bitsAllocated: frameInfo.bitsPerSample,
      rows: frameInfo.height,
      columns: frameInfo.width,
      samplesPerPixel: frameInfo.componentCount,
      pixelRepresentation: frameInfo.isSigned ? 1 : 0
    }
  }
}

/** Decode image.
 *
 * @param {object} decoder - Decoder
 * @param {Uint8Array} byteArray - Image array
 *
 * @returns {object} decoded array and frameInfo
 * @private
 */
function _decodeImage (decoder, byteArray) {
  const encodedBuffer = decoder.getEncodedBuffer(byteArray.length)
  encodedBuffer.set(byteArray)
  decoder.decode()
  return {
    frameBuffer: decoder.getDecodedBuffer(),
    frameInfo: decoder.getFrameInfo()
  }
}

export {
  decodeFrame
}
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Namespaces</h3><ul><li><a href="annotation.html">annotation</a></li><li><a href="api.html">api</a></li><li><a href="events.html">events</a></li><li><a href="mapping.html">mapping</a></li><li><a href="metadata.html">metadata</a></li><li><a href="opticalPath.html">opticalPath</a></li><li><a href="roi.html">roi</a></li><li><a href="scoord3d.html">scoord3d</a></li><li><a href="segment.html">segment</a></li><li><a href="utils.html">utils</a></li><li><a href="viewer.html">viewer</a></li></ul><h3>Classes</h3><ul><li><a href="annotation.AnnotationGroup.html">AnnotationGroup</a></li><li><a href="mapping.Mapping.html">Mapping</a></li><li><a href="metadata.Comprehensive3DSR.html">Comprehensive3DSR</a></li><li><a href="metadata.MicroscopyBulkSimpleAnnotations.html">MicroscopyBulkSimpleAnnotations</a></li><li><a href="metadata.ParametricMap.html">ParametricMap</a></li><li><a href="metadata.Segmentation.html">Segmentation</a></li><li><a href="metadata.VLWholeSlideMicroscopyImage.html">VLWholeSlideMicroscopyImage</a></li><li><a href="opticalPath.OpticalPath.html">OpticalPath</a></li><li><a href="roi.ROI.html">ROI</a></li><li><a href="scoord3d.Ellipse.html">Ellipse</a></li><li><a href="scoord3d.Ellipsoid.html">Ellipsoid</a></li><li><a href="scoord3d.Multipoint.html">Multipoint</a></li><li><a href="scoord3d.Point.html">Point</a></li><li><a href="scoord3d.Polygon.html">Polygon</a></li><li><a href="scoord3d.Polyline.html">Polyline</a></li><li><a href="segment.Segment.html">Segment</a></li><li><a href="Transformation.html">Transformation</a></li><li><a href="viewer.LabelImageViewer.html">LabelImageViewer</a></li><li><a href="viewer.OverviewImageViewer.html">OverviewImageViewer</a></li><li><a href="viewer.VolumeImageViewer.html">VolumeImageViewer</a></li></ul><h3>Global</h3><ul><li><a href="global.html#_addROIPropertiesToFeature">_addROIPropertiesToFeature</a></li><li><a href="global.html#_applyStyle">_applyStyle</a></li><li><a href="global.html#_applyStyles">_applyStyles</a></li><li><a href="global.html#_buildColorLookupTable">_buildColorLookupTable</a></li><li><a href="global.html#_computeImagePyramid">_computeImagePyramid</a></li><li><a href="global.html#_createTileLoadFunction">_createTileLoadFunction</a></li><li><a href="global.html#_getOpenLayersStyle">_getOpenLayersStyle</a></li><li><a href="global.html#_getWindowSize">_getWindowSize</a></li><li><a href="global.html#_hasMarker">_hasMarker</a></li><li><a href="global.html#_isMeasurement">_isMeasurement</a></li><li><a href="global.html#_isTextEvaluation">_isTextEvaluation</a></li><li><a href="global.html#_onInteractionEventHandler">_onInteractionEventHandler</a></li><li><a href="global.html#_setFeatureStyle">_setFeatureStyle</a></li><li><a href="global.html#_updateFeatureEvaluations">_updateFeatureEvaluations</a></li><li><a href="global.html#_updateFeatureMeasurements">_updateFeatureMeasurements</a></li><li><a href="global.html#_wireMeasurementsAndQualitativeEvaluationsEvents">_wireMeasurementsAndQualitativeEvaluationsEvents</a></li><li><a href="global.html#anchor">anchor</a></li><li><a href="global.html#applyInverseTransform">applyInverseTransform</a></li><li><a href="global.html#applyTransform">applyTransform</a></li><li><a href="global.html#are1DArraysAlmostEqual">are1DArraysAlmostEqual</a></li><li><a href="global.html#are2DArraysAlmostEqual">are2DArraysAlmostEqual</a></li><li><a href="global.html#areCodedConceptsEqual">areCodedConceptsEqual</a></li><li><a href="global.html#areNumbersAlmostEqual">areNumbersAlmostEqual</a></li><li><a href="global.html#ArrowMarker">ArrowMarker</a></li><li><a href="global.html#buildInverseTransform">buildInverseTransform</a></li><li><a href="global.html#buildTransform">buildTransform</a></li><li><a href="global.html#computeRotation">computeRotation</a></li><li><a href="global.html#createColorMap">createColorMap</a></li><li><a href="global.html#createRotationMatrix">createRotationMatrix</a></li><li><a href="global.html#createWindow">createWindow</a></li><li><a href="global.html#doContentItemsMatch">doContentItemsMatch</a></li><li><a href="global.html#format">format</a></li><li><a href="global.html#getContentItemNameCodedConcept">getContentItemNameCodedConcept</a></li><li><a href="global.html#getShortestLineBetweenOverlayAndFeature">getShortestLineBetweenOverlayAndFeature</a></li><li><a href="global.html#getUnitSuffix">getUnitSuffix</a></li><li><a href="global.html#MeasurementMarkup">MeasurementMarkup</a></li><li><a href="global.html#rescale">rescale</a></li><li><a href="global.html#TextEvaluationMarkup">TextEvaluationMarkup</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.5</a> on Wed Jan 12 2022 19:14:48 GMT-0500 (Eastern Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
