<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: metadata.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: metadata.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import { tagToKeyword } from './dictionary'
import { SOPClassUIDs } from './enums'
import { _groupFramesPerMapping } from './mapping'

function _base64ToUint8Array (value) {
  const blob = window.atob(value)
  const array = new Uint8Array(blob.length)

  for (let i = 0; i &lt; blob.length; i++) {
    array[i] = blob.charCodeAt(i)
  }

  return array
}

function _base64ToUint16Array (value) {
  const blob = window.atob(value)
  const n = Uint16Array.BYTES_PER_ELEMENT
  const length = blob.length / n
  const buffer = new ArrayBuffer(n)
  const view = new DataView(buffer)
  const array = new Uint16Array(length)

  let p = 0
  for (let i = 0; i &lt; length; i++) {
    p = i * n
    for (let j = 0; j &lt; n; j++) {
      view.setUint8(j, blob.charCodeAt(p + j))
    }
    array[i] = view.getUint16(0, true)
  }

  return array
}

function _base64ToUint32Array (value) {
  const blob = window.atob(value)
  const n = Uint32Array.BYTES_PER_ELEMENT
  const length = blob.length / n
  const buffer = new ArrayBuffer(n)
  const view = new DataView(buffer)
  const array = new Uint32Array(length)

  let p = 0
  for (let i = 0; i &lt; length; i++) {
    p = i * n
    for (let j = 0; j &lt; n; j++) {
      view.setUint8(j, blob.charCodeAt(p + j))
    }
    array[i] = view.getUint32(0, true)
  }

  return array
}

function _base64ToFloat32Array (value) {
  const blob = window.atob(value)
  const n = Float32Array.BYTES_PER_ELEMENT
  const length = blob.length / n
  const buffer = new ArrayBuffer(n)
  const view = new DataView(buffer)
  const array = new Float32Array(length)

  let p = 0
  for (let i = 0; i &lt; length; i++) {
    p = i * n
    for (let j = 0; j &lt; n; j++) {
      view.setUint8(j, blob.charCodeAt(p + j))
    }
    array[i] = view.getFloat32(0, true)
  }

  return array
}

function _base64ToFloat64Array (value) {
  const blob = window.atob(value)
  const n = Float64Array.BYTES_PER_ELEMENT
  const length = blob.length / n
  const buffer = new ArrayBuffer(n)
  const view = new DataView(buffer)
  const array = new Float64Array(length)

  let p = 0
  for (let i = 0; i &lt; length; i++) {
    p = i * n
    for (let j = 0; j &lt; n; j++) {
      view.setUint8(j, blob.charCodeAt(p + j))
    }
    array[i] = view.getFloat64(0, true)
  }

  return array
}

/** Determines the mapping of pyramid tile positions to frame numbers.
 *
 * @param {Object} Formatted metadata of a VL Whole Slide Microscopy Image instance
 * @returns {Object} Mapping of pyramid tile position (Row-Column) to frame URI
 * @private
 */
function getFrameMapping (metadata) {
  const rows = metadata.Rows
  const columns = metadata.Columns
  const totalPixelMatrixColumns = metadata.TotalPixelMatrixColumns
  const sopInstanceUID = metadata.SOPInstanceUID
  const numberOfFrames = Number(metadata.NumberOfFrames || 1)
  const frameOffsetNumber = Number(metadata.ConcatenationFrameOffsetNumber || 0)

  /**
   * Handle images that may contain multiple "planes"
   *  - z-planes (VL Whole Slide Microscopy Image)
   *  - optical paths (VL Whole Slide Microscopy Image)
   *  - segments (Segmentation)
   *  - mappings (Parametric Map)
   */
  let numberOfChannels = 0
  const numberOfFocalPlanes = Number(metadata.TotalPixelMatrixFocalPlanes || 1)
  if (numberOfFocalPlanes > 1) {
    throw new Error('Images with multiple focal planes are not yet supported.')
  }

  const {
    mappingNumberToFrameNumbers,
    frameNumberToMappingNumber
  } = _groupFramesPerMapping(metadata)
  let numberOfOpticalPaths = 0
  let numberOfSegments = 0
  let numberOfMappings = 0
  if (metadata.NumberOfOpticalPaths !== undefined) {
    numberOfOpticalPaths = Number(metadata.NumberOfOpticalPaths || 1)
    numberOfChannels = numberOfOpticalPaths
  } else if (metadata.SegmentSequence !== undefined) {
    numberOfSegments = metadata.SegmentSequence.length
    numberOfChannels = numberOfSegments
  } else if (Object.keys(mappingNumberToFrameNumbers).length > 0) {
    numberOfMappings = Object.keys(mappingNumberToFrameNumbers).length
    numberOfChannels = numberOfMappings
  } else {
    throw new Error('Could not determine the number of image channels.')
  }

  const tilesPerRow = Math.ceil(totalPixelMatrixColumns / columns)
  const frameMapping = {}
  /**
   * The values "TILED_SPARSE" and "TILED_FULL" were introduced in the 2018
   * edition of the standard. Older datasets are equivalent to "TILED_SPARSE".
   */
  const dimensionOrganizationType = (
    metadata.DimensionOrganizationType || 'TILED_SPARSE'
  )
  if (dimensionOrganizationType === 'TILED_FULL') {
    const offset = frameOffsetNumber + 1
    const limit = frameOffsetNumber + numberOfFrames
    for (let j = offset; j &lt;= limit; j++) {
      const rowIndex = Math.ceil(j / (tilesPerRow * numberOfChannels))
      const n = (
        j -
        (rowIndex * tilesPerRow * numberOfChannels) +
        (tilesPerRow * numberOfChannels)
      )
      const colIndex = Math.ceil(n / numberOfChannels)
      const channelIndex = Math.ceil(n / tilesPerRow)
      let channelIdentifier
      if (numberOfOpticalPaths > 0) {
        const opticalPath = metadata.OpticalPathSequence[channelIndex - 1]
        channelIdentifier = opticalPath.OpticalPathIdentifier
      } else if (numberOfSegments > 0) {
        const segment = metadata.SegmentIdentificationSequence[channelIndex - 1]
        channelIdentifier = String(segment.ReferencedSegmentNumber)
      } else if (numberOfMappings > 0) {
        // TODO: ensure that frames are mapped accordingly
        channelIdentifier = String(frameNumberToMappingNumber[j + 1])
      } else {
        throw new Error(`Could not determine channel of frame ${j}.`)
      }
      const index = rowIndex + '-' + colIndex + '-' + channelIdentifier
      const frameNumber = j - offset + 1
      frameMapping[index] = `${sopInstanceUID}/frames/${frameNumber}`
    }
  } else {
    const functionalGroups = metadata.PerFrameFunctionalGroupsSequence
    for (let j = 0; j &lt; numberOfFrames; j++) {
      const planePositions = functionalGroups[j].PlanePositionSlideSequence[0]
      const rowPosition = planePositions.RowPositionInTotalImagePixelMatrix
      const columnPosition = planePositions.ColumnPositionInTotalImagePixelMatrix
      const rowIndex = Math.ceil(rowPosition / rows)
      const colIndex = Math.ceil(columnPosition / columns)
      let channelIdentifier
      if (numberOfOpticalPaths > 0) {
        const opticalPath = functionalGroups[j].OpticalPathIdentificationSequence[0]
        channelIdentifier = opticalPath.OpticalPathIdentifier
      } else if (numberOfSegments > 0) {
        const segment = functionalGroups[j].SegmentIdentificationSequence[0]
        channelIdentifier = String(segment.ReferencedSegmentNumber)
      } else if (numberOfMappings > 0) {
        channelIdentifier = String(frameNumberToMappingNumber[j + 1])
      } else {
        throw new Error(`Could not determine channel of frame ${j}.`)
      }
      const index = rowIndex + '-' + colIndex + '-' + channelIdentifier
      const frameNumber = j + 1
      frameMapping[index] = `${sopInstanceUID}/frames/${frameNumber}`
    }
  }
  return {
    frameMapping,
    numberOfChannels
  }
}

/** Formats DICOM metadata structured according to the DICOM JSON model into a
 * more human friendly representation, where values of data elements can be
 * directly accessed via their keyword (e.g., "SOPInstanceUID").
 * Bulkdata elements will be skipped.
 *
 * @param {Object} metadata - Metadata structured according to the DICOM JSON model
 * @param {Object} Metadata structured according to the DICOM JSON model
 * @returns {Object} Formatted dataset and remaining bulkdata
 *
 * @memberof metadata
 */
function formatMetadata (metadata) {
  const loadJSONDataset = (elements) => {
    const dataset = {}
    const bulkDataMapping = {}
    Object.keys(elements).forEach(tag => {
      const keyword = tagToKeyword[tag]
      const vr = elements[tag].vr
      if ('BulkDataURI' in elements[tag]) {
        bulkDataMapping[keyword] = elements[tag]
      } else if ('Value' in elements[tag]) {
        const value = elements[tag].Value
        if (vr === 'SQ') {
          dataset[keyword] = []
          const mappings = []
          value.forEach(item => {
            const loaded = loadJSONDataset(item)
            dataset[keyword].push(loaded.dataset)
            mappings.push(loaded.bulkDataMapping)
          })
          if (mappings.some(item => Object.keys(item).length > 0)) {
            bulkDataMapping[keyword] = mappings
          }
        } else {
          // Handle value multiplicity.
          if (value.length === 1) {
            if (vr === 'DS' || vr === 'IS') {
              dataset[keyword] = Number(value[0])
            } else {
              dataset[keyword] = value[0]
            }
          } else {
            if (vr === 'DS' || vr === 'IS') {
              dataset[keyword] = value.map(v => Number(v))
            } else {
              dataset[keyword] = value
            }
          }
        }
      } else if ('InlineBinary' in elements[tag]) {
        const value = elements[tag].InlineBinary
        if (vr === 'OB') {
          dataset[keyword] = _base64ToUint8Array(value)
        } else if (vr === 'OW') {
          dataset[keyword] = _base64ToUint16Array(value)
        } else if (vr === 'OL') {
          dataset[keyword] = _base64ToUint32Array(value)
        } else if (vr === 'OF') {
          dataset[keyword] = _base64ToFloat32Array(value)
        } else if (vr === 'OD') {
          dataset[keyword] = _base64ToFloat64Array(value)
        }
      } else {
        if (vr === 'SQ') {
          dataset[keyword] = []
        } else {
          dataset[keyword] = null
        }
      }
    })
    return { dataset, bulkDataMapping }
  }

  const { dataset, bulkDataMapping } = loadJSONDataset(metadata)

  // The top level (lowest resolution) image may be a single frame image in
  // which case the "NumberOfFrames" attribute is optional. We include it for
  // consistency.
  if (dataset === undefined) {
    throw new Error('Could not format metadata: ', metadata)
  }
  if (!('NumberOfFrames' in dataset) &amp;&amp; (dataset.Modality === 'SM')) {
    dataset.NumberOfFrames = 1
  }

  return { dataset, bulkDataMapping }
}

/** Group DICOM metadata of monochrome slides by Optical Path Identifier.
 *
 * @param {Object[]} metadata - DICOM JSON objects representing metadata of VL Whole Slide Microscopy Image instances.
 *
 * @returns {Object[]} Groups of formatted VLWholeSlideMicroscopyImage instances
 * @memberof metadata
 */
function groupMonochromeInstances (metadata) {
  const channels = []
  for (let i = 0; i &lt; metadata.length; ++i) {
    const microscopyImage = new VLWholeSlideMicroscopyImage({
      metadata: metadata[i]
    })
    if (microscopyImage.ImageType[2] !== 'VOLUME') {
      continue
    }

    if (microscopyImage.SamplesPerPixel === 1 &amp;&amp;
        microscopyImage.PhotometricInterpretation === 'MONOCHROME2') {
      // this is a monochrome channel
      const pathIdentifier = microscopyImage.OpticalPathSequence[0].OpticalPathIdentifier
      const channel = channels.find(channel => {
        return channel[0].OpticalPathSequence[0].OpticalPathIdentifier === pathIdentifier
      })

      if (channel) {
        channel.push(microscopyImage)
      } else {
        channels.push([microscopyImage])
      }
    }
  }

  return channels
}

/** Group DICOM metadata of color images slides by Optical Path Identifier.
 *
 * @param {Object[]} metadata
 *
 * @returns {Object[]} groups of VLWholeSlideMicroscopyImages
 * @memberof metadata
 */
function groupColorInstances (metadata) {
  const colorImages = []
  for (let i = 0; i &lt; metadata.length; ++i) {
    const microscopyImage = new VLWholeSlideMicroscopyImage({
      metadata: metadata[i]
    })
    if (
      microscopyImage.ImageType[2] === 'LABEL' ||
      microscopyImage.ImageType[2] === 'OVERVIEW'
    ) {
      continue
    }

    if (
      microscopyImage.SamplesPerPixel !== 1 &amp;&amp;
      (
        microscopyImage.PhotometricInterpretation === 'RGB' ||
        microscopyImage.PhotometricInterpretation.includes('YBR')
      )
    ) {
      const opticalPathIdentifier = (
        microscopyImage
          .OpticalPathSequence[0]
          .OpticalPathIdentifier
      )
      const colorImage = colorImages.find(images => {
        const currentOpticalPathIdentifier = (
          images[0]
            .OpticalPathSequence[0]
            .OpticalPathIdentifier
        )
        return currentOpticalPathIdentifier === opticalPathIdentifier
      })

      if (colorImage) {
        colorImage.push(microscopyImage)
      } else {
        colorImages.push([microscopyImage])
      }
    }
  }

  return colorImages
}

/** DICOM VL Whole Slide Microscopy Image instance
 * (without Pixel Data or any other bulk data).
 *
 * @class
 * @memberof metadata
 */
class VLWholeSlideMicroscopyImage {
  /**
   * @params {Object} options
   * @params {Object} options.metadata - Metadata of a VL Whole Slide Microscopy Image in DICOM JSON format
   * @params {Callable} options.bulkDataHandler - Callable for retrieving bulk data values (receives BulkDataURI as input and returns the retrieved value)
   */
  constructor ({ metadata, bulkDataHandler }) {
    let dataset
    if ('StudyInstanceUID' in metadata) {
      // Has already been formatted
      dataset = metadata
    } else {
      const formatted = formatMetadata(metadata)
      dataset = formatted.dataset
    }
    if (dataset.SOPClassUID !== SOPClassUIDs.VL_WHOLE_SLIDE_MICROSCOPY_IMAGE) {
      throw new Error(
        'Cannot construct VL Whole Slide Microscopy Image instance ' +
        `given dataset with SOP Class UID "${dataset.SOPClassUID}"`
      )
    }

    Object.assign(this, dataset)
  }
}

/** DICOM Comprehensive 3D SR instance.
 *
 * @class
 * @memberof metadata
 */
class Comprehensive3DSR {
  /**
   * @params {Object} options
   * @params {Object} options.metadata - Metadata in DICOM JSON format
   * @params {Callable} options.bulkDataHandler - Callable for retrieving bulk data values (receives BulkDataURI as input and returns the retrieved value)
   */
  constructor ({ metadata, bulkDataHandler }) {
    let dataset
    if ('StudyInstanceUID' in metadata) {
      // Has already been formatted
      dataset = metadata
    } else {
      const formatted = formatMetadata(metadata)
      dataset = formatted.dataset
    }
    if (dataset.SOPClassUID !== SOPClassUIDs.COMPREHENSIVE_3D_SR) {
      throw new Error(
        'Cannot construct Comprehensive 3D SR instance ' +
          `given dataset with SOP Class UID "${dataset.SOPClassUID}"`
      )
    }

    Object.assign(this, dataset)
  }
}

/** DICOM Microscopy Bulk Simple Annotations instance.
 *
 * @class
 * @memberof metadata
 */
class MicroscopyBulkSimpleAnnotations {
  /**
   * @params {Object} options
   * @params {Object} options.metadata - Metadata of a DICOM Microscopy Bulk Simple Annotations instance in DICOM JSON format
   */
  constructor ({ metadata }) {
    let dataset
    if ('StudyInstanceUID' in metadata) {
      // Has already been formatted
      dataset = metadata
    } else {
      const formatted = formatMetadata(metadata)
      dataset = formatted.dataset
    }
    if (dataset.SOPClassUID !== SOPClassUIDs.MICROSCOPY_BULK_SIMPLE_ANNOTATIONS) {
      throw new Error(
        'Cannot construct Microscopy Bulk Simple Annotations instance ' +
          `given dataset with SOP Class UID "${dataset.SOPClassUID}"`
      )
    }

    Object.assign(this, dataset)
  }
}

/** DICOM Parametric Map instance.
 *
 * @class
 * @memberof metadata
 */
class ParametricMap {
  /**
   * @params {Object} options
   * @params {Object} options.metadata - Metadata of a DICOM Parametric Map instance in DICOM JSON format
   */
  constructor ({ metadata }) {
    let dataset
    if ('StudyInstanceUID' in metadata) {
      // Has already been formatted
      dataset = metadata
    } else {
      const formatted = formatMetadata(metadata)
      dataset = formatted.dataset
    }
    if (dataset.SOPClassUID !== SOPClassUIDs.PARAMETRIC_MAP) {
      throw new Error(
        'Cannot construct Parametric Map instance ' +
          `given dataset with SOP Class UID "${dataset.SOPClassUID}"`
      )
    }

    Object.assign(this, dataset)
  }
}

/** DICOM Segmentation instance.
 *
 * @class
 * @memberof metadata
 */
class Segmentation {
  /**
   * @params {Object} options
   * @params {Object} options.metadata - Metadata of a DICOM Segmentation instance in DICOM JSON format
   */
  constructor ({ metadata }) {
    let dataset
    if ('StudyInstanceUID' in metadata) {
      // Has already been formatted
      dataset = metadata
    } else {
      const formatted = formatMetadata(metadata)
      dataset = formatted.dataset
    }
    if (dataset.SOPClassUID !== SOPClassUIDs.SEGMENTATION) {
      throw new Error(
        'Cannot construct Segmentation instance ' +
          `given dataset with SOP Class UID "${dataset.SOPClassUID}"`
      )
    }

    Object.assign(this, dataset)
  }
}

export {
  Comprehensive3DSR,
  formatMetadata,
  groupMonochromeInstances,
  groupColorInstances,
  getFrameMapping,
  MicroscopyBulkSimpleAnnotations,
  ParametricMap,
  Segmentation,
  VLWholeSlideMicroscopyImage
}
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Namespaces</h3><ul><li><a href="annotation.html">annotation</a></li><li><a href="api.html">api</a></li><li><a href="events.html">events</a></li><li><a href="mapping.html">mapping</a></li><li><a href="metadata.html">metadata</a></li><li><a href="opticalPath.html">opticalPath</a></li><li><a href="roi.html">roi</a></li><li><a href="scoord3d.html">scoord3d</a></li><li><a href="segment.html">segment</a></li><li><a href="utils.html">utils</a></li><li><a href="viewer.html">viewer</a></li></ul><h3>Classes</h3><ul><li><a href="annotation.AnnotationGroup.html">AnnotationGroup</a></li><li><a href="mapping.Mapping.html">Mapping</a></li><li><a href="metadata.Comprehensive3DSR.html">Comprehensive3DSR</a></li><li><a href="metadata.MicroscopyBulkSimpleAnnotations.html">MicroscopyBulkSimpleAnnotations</a></li><li><a href="metadata.ParametricMap.html">ParametricMap</a></li><li><a href="metadata.Segmentation.html">Segmentation</a></li><li><a href="metadata.VLWholeSlideMicroscopyImage.html">VLWholeSlideMicroscopyImage</a></li><li><a href="opticalPath.OpticalPath.html">OpticalPath</a></li><li><a href="roi.ROI.html">ROI</a></li><li><a href="scoord3d.Ellipse.html">Ellipse</a></li><li><a href="scoord3d.Ellipsoid.html">Ellipsoid</a></li><li><a href="scoord3d.Multipoint.html">Multipoint</a></li><li><a href="scoord3d.Point.html">Point</a></li><li><a href="scoord3d.Polygon.html">Polygon</a></li><li><a href="scoord3d.Polyline.html">Polyline</a></li><li><a href="segment.Segment.html">Segment</a></li><li><a href="Transformation.html">Transformation</a></li><li><a href="viewer.LabelImageViewer.html">LabelImageViewer</a></li><li><a href="viewer.OverviewImageViewer.html">OverviewImageViewer</a></li><li><a href="viewer.VolumeImageViewer.html">VolumeImageViewer</a></li></ul><h3>Global</h3><ul><li><a href="global.html#_addROIPropertiesToFeature">_addROIPropertiesToFeature</a></li><li><a href="global.html#_applyStyle">_applyStyle</a></li><li><a href="global.html#_applyStyles">_applyStyles</a></li><li><a href="global.html#_buildColorLookupTable">_buildColorLookupTable</a></li><li><a href="global.html#_computeImagePyramid">_computeImagePyramid</a></li><li><a href="global.html#_createTileLoadFunction">_createTileLoadFunction</a></li><li><a href="global.html#_getOpenLayersStyle">_getOpenLayersStyle</a></li><li><a href="global.html#_getWindowSize">_getWindowSize</a></li><li><a href="global.html#_hasMarker">_hasMarker</a></li><li><a href="global.html#_isMeasurement">_isMeasurement</a></li><li><a href="global.html#_isTextEvaluation">_isTextEvaluation</a></li><li><a href="global.html#_onInteractionEventHandler">_onInteractionEventHandler</a></li><li><a href="global.html#_setFeatureStyle">_setFeatureStyle</a></li><li><a href="global.html#_updateFeatureEvaluations">_updateFeatureEvaluations</a></li><li><a href="global.html#_updateFeatureMeasurements">_updateFeatureMeasurements</a></li><li><a href="global.html#_wireMeasurementsAndQualitativeEvaluationsEvents">_wireMeasurementsAndQualitativeEvaluationsEvents</a></li><li><a href="global.html#anchor">anchor</a></li><li><a href="global.html#applyInverseTransform">applyInverseTransform</a></li><li><a href="global.html#applyTransform">applyTransform</a></li><li><a href="global.html#are1DArraysAlmostEqual">are1DArraysAlmostEqual</a></li><li><a href="global.html#are2DArraysAlmostEqual">are2DArraysAlmostEqual</a></li><li><a href="global.html#areCodedConceptsEqual">areCodedConceptsEqual</a></li><li><a href="global.html#areNumbersAlmostEqual">areNumbersAlmostEqual</a></li><li><a href="global.html#ArrowMarker">ArrowMarker</a></li><li><a href="global.html#buildInverseTransform">buildInverseTransform</a></li><li><a href="global.html#buildTransform">buildTransform</a></li><li><a href="global.html#computeRotation">computeRotation</a></li><li><a href="global.html#createColorMap">createColorMap</a></li><li><a href="global.html#createRotationMatrix">createRotationMatrix</a></li><li><a href="global.html#createWindow">createWindow</a></li><li><a href="global.html#doContentItemsMatch">doContentItemsMatch</a></li><li><a href="global.html#format">format</a></li><li><a href="global.html#getContentItemNameCodedConcept">getContentItemNameCodedConcept</a></li><li><a href="global.html#getShortestLineBetweenOverlayAndFeature">getShortestLineBetweenOverlayAndFeature</a></li><li><a href="global.html#getUnitSuffix">getUnitSuffix</a></li><li><a href="global.html#MeasurementMarkup">MeasurementMarkup</a></li><li><a href="global.html#rescale">rescale</a></li><li><a href="global.html#TextEvaluationMarkup">TextEvaluationMarkup</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.5</a> on Wed Jan 12 2022 19:14:48 GMT-0500 (Eastern Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
